
















<!DOCTYPE html>
<html lang='uk-UA'><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <link rel="shortcut icon" href='http://localhost:1313/favicon.ico' type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>How to test videostream? - avramukk</title>

    

    

    
    <meta name="author" content="Mykola Avramuk" />
    

    
        <meta property="og:url" content="http://localhost:1313/ua/post0/">
  <meta property="og:site_name" content="avramukk">
  <meta property="og:title" content="How to test videostream?">
  <meta property="og:description" content="Привіт! Мене звати Микола Аврамук. Я QA та Streaming Engineer в Mixa.live. Хочу поділитись своїм досвідом тестування лайв-відеострімінгу, а також отримати поради від ком’юніті.
Підписуйтесь на мій блог на Substack
Коли ми читаємо статті про тестування потокового відео, ми часто розглядаємо PSNR, VMAF і SSIM. Найкраще, коли система стабільна і працює так, як очікується, щоб ми могли почати тестування обʼєктивних метрик, таких як VMAF.
Або коли ви вже є Netflixʼом:">
  <meta property="og:locale" content="uk_UA">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2023-09-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-05-31T14:34:47+01:00">
    <meta property="article:tag" content="Streaming">
    <meta property="article:tag" content="Qa">

    

    
        
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="How to test videostream?">
  <meta name="twitter:description" content="Привіт! Мене звати Микола Аврамук. Я QA та Streaming Engineer в Mixa.live. Хочу поділитись своїм досвідом тестування лайв-відеострімінгу, а також отримати поради від ком’юніті.
Підписуйтесь на мій блог на Substack
Коли ми читаємо статті про тестування потокового відео, ми часто розглядаємо PSNR, VMAF і SSIM. Найкраще, коли система стабільна і працює так, як очікується, щоб ми могли почати тестування обʼєктивних метрик, таких як VMAF.
Або коли ви вже є Netflixʼом:">

    <link rel="stylesheet" href="/style.css" integrity="">





    
    <script>
        if (!('theme' in localStorage)) {
            localStorage.theme = 'dark';
        }

        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.setAttribute("data-theme", "dark");
        } else {
            document.documentElement.setAttribute("data-theme", "light");
        }
    </script>
<script defer src="/js/header.js" integrity=""></script>



    <script defer src="/js/zooming.js" integrity=""></script>












<link rel="stylesheet" href="http://localhost:1313/user.css">

    
</head>
<body><header>
    <div id="header_left">
        <div id="sidebar_btn">
            <input type="checkbox" id="sidebar_btn_input" class="hidden" />
            <label id="sidebar_btn_label" for="sidebar_btn_input">
                <svg id="menu_icon" width="26px" height="26px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
</svg>

</svg>
            </label>
            <label id="sidebar_canvas_overlay_wrapper" for="sidebar_btn_input">
                <div id="sidebar_canvas_overlay"></div>
            </label>
            <div id="sidebar">
                <ul></ul>
            </div>
        </div>

        <div class="brand">
            <div>
                <a href="/ua/">avramukk</a>
            </div>
        </div>
    </div>

    <div class="toolbox">
        <div id="theme_tool">
            <svg id="dark_mode_btn" class="toolbox-btn" width="15px" height="15px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

</svg>
            <svg id="light_mode_btn" class="toolbox-btn" width="15px" height="15px" viewBox="0 0 24 24">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="24" height="24" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
</svg>

</svg>
        </div>

        

        
        <div id="translation_tool" class="dropdown-wrapper pure-menu pure-menu-horizontal toolbox-btn"
            onclick="void(0)">
            <ul class="pure-menu-list">
                <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
                    <div class="dropdown-btn pure-menu-link">
                        
                        <span class="dropdown-desc">ua</span>
                    </div>
                    <ul class="pure-menu-children">
                        
                        <li class="pure-menu-item">
                            <a href="http://localhost:1313/" class="pure-menu-link">en</a>
                        </li>
                        
                        <li class="pure-menu-item">
                            <a href="http://localhost:1313/ua/" class="pure-menu-link">ua</a>
                        </li>
                        
                    </ul>
                </li>
            </ul>
        </div>
        
    </div>
</header><nav id="navbar" class="pure-menu">
    <ul class="pure-menu-list"></ul>
</nav>
<main>
        <div id="content" class="content-margin">
            


    <div class="content-margin">



<article >
    
    
        
        
    
    <p>Привіт! Мене звати <a href="http://avramukk.com">Микола Аврамук</a>. Я QA та Streaming Engineer в <a href="http://mixa.live/">Mixa.live</a>.
Хочу поділитись своїм досвідом тестування лайв-відеострімінгу, а також отримати поради від ком’юніті.</p>
<p>Підписуйтесь на мій блог на <a href="https://avramukk.substack.com">Substack</a></p>
<p>Коли ми читаємо статті про тестування потокового відео, ми часто розглядаємо PSNR, VMAF і SSIM. Найкраще, коли система стабільна і працює так, як очікується, щоб ми могли почати тестування <a href="https://videocompressionguru.medium.com/interpretation-of-objective-video-quality-metrics-56516d1884df">обʼєктивних метрик</a>, таких як VMAF.</p>
<p>Або коли ви вже є Netflixʼом:</p>
<p><a href="https://netflixtechblog.com/netflix-video-quality-at-scale-with-cosmos-microservices-552be631c113">Netflix Video Quality at Scale with Cosmos Microservices</a></p>
<p><a href="https://netflixtechblog.com/toward-a-practical-perceptual-video-quality-metric-653f208b9652">Toward a Better Quality Metric for the Video Community</a> </p>
<p>Але ніхто не розповідає, що відбувається до цього етапу. Тут я поясню цей етап з точки зору інженера з якості.</p>
<p><em>Дисклеймер: цей матеріал — поверхневий огляд, без деталей. Глибоке занурення будемо робити в наступних статтях</em>.</p>
<h2>Стратегія</h2>
<h3>Архітектура</h3>
<p>Перш ніж перевіряти щось, важливо розуміти, які проблеми вирішує продукт, як він працює, з яких частин складається та як вони взаємодіють. Ця інформація допоможе ухвалювати рішення щодо тестування.</p>
<p>Чим раніше почати планувати QA, тим краще. Де ще знайти краще використання підходу «shift left»?</p>
<p>Багато стрімінгових сервісів базуються на транскодер-сервері або кластері таких серверів.</p>
<p>На цьому сервері є програма, яка містить енкодери, декодери, мультиплексери, фільтри та інші модулі, які виконують певні завдання з перетворення сирого відео і аудіо в щось, що можна було б передати вам на ютуб.</p>
<p>Зазвичай процес передачі відеопотоку включає такі етапи:</p>
<ol>
<li>Кодування (<a href="https://videocompressionguru.medium.com/video-encoding-in-simple-terms-7c258fd02e82">Encoding</a>). Першим кроком є енкодування аудіо та відео даних у цифровий формат. Енкодер перетворює аналогові сигнали або сигнали з камер в цифровий формат, такий як H.264 або H.265 (також відомий як AVC і HEVC відповідно), який ефективно зберігає відео та аудіодані при відносно низькому обсязі даних.</li>
<li>Пакування у контейнер (Containerization). Після енкодування відео та аудіо дані упаковуються в контейнерний формат. MPEG-TS (MPEG Transport Stream) може бути одним з варіантів для контейнера, особливо якщо ви маєте справу з традиційними телекомунікаційними технологіями. Інші популярні контейнери включають MP4, FLV, WebM, а також спеціалізовані контейнери для різних протоколів стрімінгу.</li>
<li>Адаптивна або однорівнева передача (Adaptive or Single Bitrate Streaming). Залежно від обраної стратегії передачі, ви можете вибрати адаптивну або однорівневу передачу. В адаптивній стратегії відео дані енкодуються у різні роздільні здатності та бітрейти, і плеєр вибирає найбільш відповідний потік для конкретних умов мережі та відомостей про пристрій. В однорівневій передачі ви передаєте один конкретний потік.</li>
<li>Транспортування (Transport). Після енкодування та упакування в контейнер, відеодані готові до передачі мережею. Залежно від обраного протоколу можуть використовуватися різні механізми для транспортування. Протоколи, такі як RTMP, SRT, HLS, MPEG-DASH та WebRTC, надають специфічні механізми для передачі даних.</li>
<li>Мережева передача (Network Transmission). Відеодані передаються мережею до серверів, які можуть бути розташовані в різних регіонах або на серверах доставляння контенту (CDN — Content Delivery Network). Це забезпечує оптимальну швидкість та доступність стріму для глядачів з усього світу.</li>
<li>Декодування та відтворення (Decoding and Playback). На стороні глядача відеодані декодуються і відтворюються. Плеєр розпізнає формат контейнера та вибирає відповідний декодер для розкодування відео- та аудіоданих.</li>
</ol>
<p>Готовий декодований потік ми спробуємо прийняти, перевірити його параметри.</p>
<p>Спочатку нам потрібно дізнатись, чи можемо ми ізолювати цю програму, щоб перевірити правильність її роботи без втручання будь-чого зі сторони. Якщо це можливо, потрібно обовʼязково цим скористатися, бо це зекономить багато часу, щоб ізолювати проблеми. Якщо такої можливості немає, то використовуємо те, що доступно, але краще, щоб тестове середовище було копією виробничого або було виробничим.</p>
<p>Дізнайтеся, на якій операційній системі працює додаток, щоб підготувати інструменти для логування і збору артефактів, які допоможуть швидше відтворювати й ізолювати проблеми.</p>
<h2>Що перевіряти</h2>
<p>Плануючи, що ви будете тестувати, потрібно дослідити вимоги і поставити <a href="https://testing.googleblog.com/2016/06/the-inquiry-method-for-test-planning.html">ключові питання</a> про те, які особливості має система і якої роботи від неї очікують.</p>
<p>Потокове відео передається за допомогою протоколів передачі. Це набір правил, які визначають, як відео і аудіо передаються мережею. Наприклад, ті що частіше зустрічаються - RTMP, SRT, HLS, MPEG-DASH, WebRTC. Кожен з них має свої особливості і перед тестуванням варто розуміти, як вони працюють. Ось <a href="https://www.wowza.com/blog/streaming-protocols">тут</a> добре описано основи їх роботи.</p>
<p>Будь-яка передача починається зі встановлення зʼєднання. Тому потрібно протестувати коректне встановлення з’єднань, виходячи з реалізацій різних протоколів. Всі вони використовують зʼєднання типу клієнт-сервер. А webRTC може і client-client.</p>
<p>Обовʼязково потрібно перевірити і негативні сценарії, коли зʼєднання не повинно бути встановлене, та різні випадки, повʼязані з контролем доступу.</p>
<p>Для тестування потоку нам потрібно його прийняти (як клієнт), декодувати і зберегти в контейнер, щоб подивись на дані, які там лежать. Або якщо у вас є інструменти, які можуть показати перевірені параметри сигналу на льоту — це дуже круто, варто ними скористатись.</p>
<p>Візьмемо як приклад SRT. Для перевірки встановлення зʼєднання можна використати Wireshark, щоб перехоплювати весь трафік і проаналізувати як встановлення з&rsquo;єднань, так і подальшу передачу. Ось <a href="https://youtu.be/SS3sb8Pg41k">в цьому відео гарно</a> пояснено, як це зробити.</p>
<p>Приймаємо цей стрім доступним вам декодером (як приклад, ffmpeg або vlc) і направляємо вихід у файл (контейнер). Гарний гайд з контейнерів можна почитати <a href="https://bitmovin.com/container-formats-fun-1">тут</a>.</p>
<p>Коли зʼєднання успішно встановлено, передача відео почалась, і вивід збережено до файлу, можемо перейти до перевірок параметрів транспортного потоку. А саме відео, аудіо, метаданих і всього, що може помістити в собі потік.</p>
<p>Переглянемо ці параметри (на прикладі mpeg ts, який прийнято по <a href="https://youtu.be/VrE3dJej5IE">SRT</a>).</p>
<h3>Відео</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/MPEG_transport_stream#:~:text=of%20the%20payload.-,Packet%20identifier%20(PID),-%5Bedit%5D">PID</a>: використовується в MPEG-2 транспортному потоці, який зазвичай слугує для передачі відео та аудіо в мережах та системах трансляції для ідентифікації різних типів даних, таких як відео, аудіо, субтитри тощо, і допомагає забезпечити їх коректну передачу та синхронізацію. Я зустрічав системи, які приймали відео та аудіо на конкретних номерах PIDs, тому як мінімум ви маєте перевірити, які номери присвоюються вашим потокам. Перевірити кілька PIDs з різним вмістом.</li>
<li><a href="https://medium.com/@ceciliadigiarty/understanding-of-video-codec-and-video-container-format-16c6bd353c9d">Кодек</a>: перевіряємо лише ті, що підтримуються вашим енкодером. Найпопулярніші зараз H.264, H.265, VP9, AV1, MPEG-4. Звертайте увагу на те, що деякі кодеки потребують багато ресурсів. А ще гірше, якщо мультипоточність не підтримується або не налаштована, і все навантаження ляже на одне ядро, і воно буде завантажене більше ніж на 70-80%, то сервер може тротлити, а потік може бути пошкодженим, а тести будуть необʼєктивними.</li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Video_Coding#Profiles:~:text=%D0%B2%20%D0%BD%D0%B0%D1%81%D1%82%D1%83%D0%BF%D0%BD%D0%BE%D0%BC%D1%83%20%D1%80%D0%BE%D0%B7%D0%B4%D1%96%D0%BB%D1%96.-,%D0%9F%D1%80%D0%BE%D1%84%D1%96%D0%BB%D1%96,-%5B%5D">Profile</a>: оголошуються за допомогою коду профілю (profile_idc), а іноді набору додаткових обмежень, що застосовуються в кодері. Код профілю та зазначені обмеження дозволяють дешифратору розпізнати вимоги до декодування цього конкретного бітового потоку.</li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Video_Coding#Levels:~:text=%D0%A2%D0%B0%D0%BA-,%D0%A0%D1%96%D0%B2%D0%BD%D1%96,-%5B%5D">Level</a>: це певний набір обмежень, які вказують на ступінь необхідної продуктивності декодера для профілю. Наприклад, рівень підтримки в профілі визначає максимальну роздільну здатність зображення, частоту кадрів і швидкість потоку, які може використовувати декодер. Декодер, який відповідає цьому рівню, повинен мати можливість декодувати всі бітові потоки, закодовані для цього рівня, і всі нижчі рівні.</li>
<li><a href="https://en.wikipedia.org/wiki/Chroma_subsampling#Types_of_sampling_and_subsampling:~:text=External%20links-,Chroma%20subsampling,-14%20languages">chroma format</a>: практика кодування зображень шляхом реалізації меншої роздільної здатності для <a href="https://en.wikipedia.org/wiki/Information">хромаінформаці</a>ї, ніж для інформації <a href="https://en.wikipedia.org/wiki/Luma_(video)">Luma</a>, використовуючи переваги нижчої гостроти зорової системи людини для розрізнення кольорів.</li>
<li><a href="https://www.viewsonic.com/library/tech/monitor-resolution-aspect-ratio">resolution</a>: розміри фреймів у вашому потоці. Один з головних параметрів потоку. Якість вашого відео буде кращою зі збільшенням resolution. Але чим він вищий, тим більший бітрейт потрібен. І не забувайте дивитися на рівень завантаження системи на 2,4,8K.</li>
</ul>
<ol>
<li>SD (Standard Definition):
480p: Around 500 Kbps to 1.5 Mbps</li>
<li>HD (High Definition):
720p: Around 1.5 Mbps to 4 Mbps
1080p: Around 3 Mbps to 6 Mbps</li>
<li>Full HD:
1080p: Around 3 Mbps to 6 Mbps</li>
<li>2K:
1440p: Around 6 Mbps to 10 Mbps</li>
<li>4K:
2160p: Around 12 Mbps to 25 Mbps</li>
<li>8K:
4320p: Can vary significantly, but generally upwards of 30 Mbps</li>
<ul>
<li><a href="https://videocompressionguru.medium.com/what-is-bitrate-what-is-the-difference-between-cbr-and-vbr-f89a3241012d">bitrate</a>: це кількість даних, яка передається за одиницю часу при відтворенні або передачі відео. Він вимірюється в бітах на секунду (bps). Відтворіть отримані відео та оцініть якість кожного варіанту бітрейту. Для цього можна використовувати візуальну оцінку або об’єктивні метри якості, такі як PSNR (Peak Signal-to-Noise Ratio) чи SSIM (Structural Similarity Index).</li>
</ul>
<p>Він може бути CBR (Constant Bit Rate): CBR означає, що бітрейт залишається постійним протягом всього відео. Незалежно від складності контенту, однаковий обсяг даних використовується на всіх етапах кодування.</p>
<img src="https://s.dou.ua/storage-files/image_99677478541694527418483.jpg" />
<p>VBR (Variable Bit Rate): VBR означає, що бітрейт варіюється в залежності від складності вмісту. Чим складніша сцена, тим більше даних треба передати.</p>
<img src="https://s.dou.ua/storage-files/image_43569199131694527418467.jpg" />
<ul>
<li>framerate: частота кадрів, з якою передається відеосигнал. Бувають 24, 25,30,50,60,120. Перевірити частоту кадрів можна такими інструментами як ffprobe, mediainfo або VLC (не рекомендую, бо іноді він обманює). Для перевірки варто використати якісні вхідні дані, щоб бачити номер кожного кадру і переглянувши кожен фрейм, бути впевненим, що втрат кадрів немає.</li>
</ul>
<img src="https://s.dou.ua/storage-files/image_15914162121694527418956_wmB6T1w.gif" />
<p>Частота кадрів, як і бітрейт, може мати або CFR (Constant Frame Rate). У цьому режимі кожен кадр кодується з однаковою швидкістю і весь відеоролик використовує однакову кількість кадрів на секунду (fps). Або VFR (Variable Frame Rate) — у цьому режимі частота кадрів може варіюватися в залежності від складності контенту. Це може бути корисним для ситуацій, коли певні частини відео менш складні та можуть використовувати менше кадрів на секунду для економії обсягу даних, а складніші сцени можуть мати більше кадрів для забезпечення кращої якості.</p>
<ul>
<li><a href="https://videocompressionguru.medium.com/group-of-pictures-and-its-structure-8d9c4ea20852">GOP</a>: Group of Pictures (Група кадрів). У відеокодуванні GOP — це послідовність відеокадрів, що містить ключовий кадр (I-кадр) та один або декілька передбачуваних кадрів P та B, які використовують інформацію з попередніх або майбутніх кадрів для стиснення даних.</li>
</ul>
<img src="https://s.dou.ua/storage-files/image_67235046781694527418518.jpg" />
<ol>
<li>I-кадр (ключовий кадр). Це кадр, який не залежить від інших кадрів у GOP. Він містить повну інформацію про відеосцену і може використовуватися для декодування сам по собі. Оскільки I-кадр не залежить від інших кадрів, він зазвичай має більший розмір, ніж інші типи кадрів.</li>
<li>P-кадр (передбачуваний кадр). Ці кадри передбачаються на основі I-кадрів та інших P-кадрів в попередніх GOP. Вони містять тільки зміни відносно попередніх кадрів, що дозволяє зберігати їх з меншим об’ємом даних.</li>
<li>B-кадр (кадр між I та P). Ці кадри містять інформацію, яка базується на двох інших кадрах — I та P. Вони можуть ще більше зменшити об’єм даних.</li>
</ol>
<p>Як правило, B frame не використовують в відеотрансляції з низькою затримкою з наступних причин:</p>
<ul>
<li>Затримка обчислень. Відеокодеки вимагають більше обчислень для декодування B-кадрів, оскільки їх потрібно побудувати на основі інших кадрів. Це може призвести до збільшення загальної затримки відеостріму.</li>
<li>Затримка передачі. Використання B-кадрів може збільшити обсяг даних, які потрібно передати для відтворення відео. Це може вплинути на пропускну здатність мережі та збільшити затримку при передачі даних.</li>
<li>Якість інтерполяції. Використання B-кадрів вимагає інтерполяції між референтними кадрами (I або P) для побудови B-кадрів. Це може призвести до певного рівня додаткової артефактності або зниження якості відтворення.</li>
<li>Можливий розрив зв’язку. У випадку втрати B-кадра може виникнути проблема з декодуванням наступних кадрів, які можуть бути залежні від нього. Це може призвести до погіршення якості відтворення або затримок у відеострімі.</li>
</ul>
<p>Тестуйте, чи правильно енкодер задає структуру GOP та чи правильно decoder розуміє та декодує цю структуру. Підготуйте різні варіанти тестових даних, з різним розміром та наповненням GOP.</p>
<p>Перевірити структуру GOP в потоці можна спеціальними інструментами.</p>
<img src="https://s.dou.ua/storage-files/image_534496770131694527419379_Ye8nYI4.gif" />
<ul>
<li>key frame interval — показує відстань між ключовими I кадрами. Задається або в кількості кадрів, або в секундах. Можна підготувати різні тестові дані. Починаючи від того, що відео має абсолютно всі ключові кадри і до 10 секунд між ключовими кадрами. Дивимось як поводиться енкодер, який кодує такі відстані, та декодер, який буде це декодовувати. Оцінюємо якість зображення на різних інтервалах ключових кадрів.</li>
<li><a href="https://trac.ffmpeg.org/wiki/colorspace">color space</a> — колірний простір описує, як масив значень пікселів повинен відображатися на екрані. Він надає таку інформацію як значення пікселів у файлі, а також діапазон та значення цих значень. Перевіряємо, чи коректно декодер розуміє закодоване відео при різних значеннях, наприклад:
<ul>
<li>[BT.601](<a href="https://en.wikipedia.org/wiki/Rec._601">en.wikipedia.org/wiki/Rec._601</a>) («Стандартна чіткість» або SD)</li>
<li>[BT.709](<a href="https://en.wikipedia.org/wiki/Rec._709">en.wikipedia.org/wiki/Rec._709</a>) («високої чіткості» або HD)</li>
<li>[BT.2020](<a href="https://en.wikipedia.org/wiki/Rec._2020">en.wikipedia.org/wiki/Rec._2020</a>) («Ultra-High-Definition» або UHD)</li>
<li>bit depth: бітова глибина в відео належить до кількості бітів, використаних для представлення інформації про кольори кожного пікселя на зображенні або кадрі. Зазвичай в відео використовуються такі бітові глибини як 8 біт, 10 біт та 12 біт. Перевіряємо кожне значення.</li>
</ul></li>
</ul>
<img src="https://live.staticflickr.com/65535/50663132616_8666ed1de8_b.jpg" />
<ul>
<li>Scan type. Progressive та interlaced — це два різних підходи до відображення зображення на екрані, зокрема у відео.
<ul>
<li>Progressive (прогресивне сканування). У цьому режимі кожен кадр відео відображається повністю і всі рядки зображення обробляються одразу. Всі пікселі на екрані оновлюються одразу ж, що робить зображення чіткішим та плавним. Відео у форматі 720p, 1080p, 4K тощо використовують progressive сканування.</li>
<li>Interlaced (черезрядкове сканування). У цьому режимі кадр поділяється на дві половини — парні та непарні рядки. Спочатку відображаються всі парні рядки, а потім — непарні. Це було винайдено для зменшення кількості інформації, яку потрібно передати через обмежені канали зв’язку.</li>
</ul></li>
</ul>
<img src="https://s.dou.ua/storage-files/image_55682421461694527418497.jpg" />
<ul>
<li>aspect ratio — співвідношення сторін відеофрейму. Ваша система має коректно розуміти кожен тип і додавати чорні смуги, коли це необхідно, або ж передавати лише корисне навантаження згідно співвідношення сторін. Перевіряємо популярні значення і ті, які задані у вимогах.</li>
</ul>
<img src="https://s.dou.ua/storage-files/image_753878354101694527418562.jpg" />
<ul>
<li>A/V syncronization: синхронізація аудіо та відео. Відома як lipsync. Готуємо відповідний контент, в якому можна легко зрозуміти зсув звуку та зображення.</li>
</ul>
<img src="https://s.dou.ua/storage-files/image_38130962151694527418488_JJECqNT.gif" />
<ul>
<li>NTP sync: якщо ваш сервіс підтримує синхронізацію потоків за таймкодами, то потрібно перевірити, що це працює коректно. NTP працює над синхронізацією ваших потоків через відеокодери. NTP — це абревіатура від протоколу мережевого часу, інтернет-стандарту, який функціонує шляхом синхронізації ваших серверів і пристроїв з всесвітнім координованим часом (UTC). NTP працює шляхом синхронізації ваших пристроїв (у цьому випадку кодерів і декодерів) з NTP-сервером, який, своєю чергою, синхронізується з годинником «grandmaster» (часто одним з атомних годинників або GPS-годинником). NTP має точність до десятків мілісекунд через Інтернет, а за ідеальних обставин може бути точним до субмілісекундних рівнів. І ця точність — від годинника гросмейстера до вашого пристрою. Таким чином, ваші пристрої (які всі повинні бути підключені до одного NTP-сервера) будуть дуже близькі одне до одного з точки зору точності часу.</li>
<li>PTS/DTS: PTS (Presentation Time Stamp) вказує на час, коли певний кадр або аудіофрагмент повинен бути показаний на екрані або відтворений на аудіовиході. DTS (Decoding Time Stamp) вказує на час, коли певний кадр або аудіофрагмент повинен бути декодований. <a href="https://www.elecard.com/page/timestamp_validation_in_transport_stream">Тут</a> добре описано, як перевірити правильність цих міток у відеопотоці.</li>
<li>Latency — це затримка, яка виникає між моментом створення відеосигналу на стороні джерела та моментом відтворення цього відеосигналу на стороні кінцевого користувача.</li>
</ul>
<img src="https://s.dou.ua/storage-files/image_49643384121694527418465.jpg" />
<p>Як і в будь-яких інших методологіях вимірювання, існують більш і менш точні способи зробити це. Звичайний метод, який багато хто використовує, — це поставити високоточний цифровий секундомір перед камерою і зробити фотографію під час відтворення секундоміра уже декодованого потоку на екрані. Але якщо для вас цього недостатньо, то є <a href="https://www.researchgate.net/publication/307516190_A_system_for_high_precision_glass-to-glass_delay_measurements_in_video_communication">наукові роботи</a>, за якими можна поміряти точніше.</p>
<img src="https://s.dou.ua/storage-files/image_435895114111694527418591.jpg" />
<h3>Аудіо</h3>
<ul>
<li>PID: перевірте, що піди мають очікувані ідентифікаційні номери і що вони коректно декодуються і відтворюються.</li>
<li>Codec: як і у відео, у аудіо є свої кодеки AAC, MP3, AC3, DTS, а також нестиснений звук PCM, що використовується для точного відтворення аудіосигналу, не застосовуючи стиснення даних.</li>
<li>Bitrate: 96, 128, 192, 256 — перевіряємо, що енкодер правильно кодує значення і звук проходить без спотворень</li>
<li>Channel layout: перевіряємо різні схеми каналів звуку, такі як mono, stereo (2.0), 2.1, 5.1, 7.1, 7.1.2, 9.1. Підготуйте багато комбінацій різних тестових даних, щоб перевіряти, чи правильно транскодер їх обробляє.</li>
<li>Sample rate (частота дискретизації) — це параметр, який визначає, скільки разів за секунду збираються дані з аналогового звуку для перетворення їх в цифровий формат. Це є однією з ключових характеристик цифрового аудіо. Sample rate вимірюється в герцах (Гц) і вказує на кількість аудіосемплів, які записуються за одну секунду. Стандартним sample rate є 44100 Гц або 48000 Гц.</li>
<li>Bit depth: параметр, який визначає точність зберігання або передачі звукової інформації у цифровому форматі. Вона вимірюється в бітах і показує, скільки різних значень може бути представлено для кожного аудіосемпла. Чим вища бітова глибина, тим більше можливих значень може бути записано для кожного звукового семпла, що спричиняє більшу точність і деталізацію звуку. Перевіряємо поширені значення: 8,16, 24, 32 біт.</li>
</ul>
<p>Використовуйте тестові дані різного вмісту: людський голос, музика, шум, різні рівні аудіотону. Перевіряйте також пікові та кліпуючі (&gt;0dB) значення.</p>
<h3>Метадата</h3>
<p>Далі варто перевірити метадані транспортного потоку, а для цього потрібно розуміти, що це.</p>
<p><strong>Program Association Table (PAT).</strong> Ця таблиця надає інформацію про доступні програми у потоці MPEG-TS. Вона включає ідентифікатор таблиці відображення програми (PMT) для кожної програми, що дозволяє приймачам знаходити відповідну PMT для додаткової інформації.</p>
<p><strong>Program Map Table (PMT).</strong> PMT надає деталі про компоненти конкретної програми, такі як аудіопотоки, відеопотоки, субтитри та інші дані. Кожен компонент ідентифікується ідентифікатором пакета (PID), а PMT допомагає приймачам розуміти, як обробляти та декодувати різні компоненти.</p>
<p><strong>Service Information (SI).</strong> Метадані SI містять інформацію про послуги, такі як назви програм, описи та інформацію про постачальників послуг. Ці метадані допомагають користувачам визначити вміст, який вони хочуть переглядати.</p>
<p><strong>Conditional Access Table (CAT).</strong> Ця таблиця містить інформацію, пов’язану з системами умовного доступу, які керують шифруванням та розшифруванням вмісту для авторизованих глядачів.</p>
<p><strong>Event Information Table (EIT).</strong> Метадані EIT надають деталі про заплановані події, зокрема час початку, тривалість та назви програм. Вони особливо корисні для електронних програмних довідників (EPG), які допомагають користувачам навігувати серед доступного вмісту.</p>
<p><strong>Network Information Table (NIT).</strong> Метадані NIT містять інформацію про саму мережу, таку як параметри налаштування, частота та деталі модуляції. Це особливо важливо для приймачів, щоб правильно налаштуватися на бажані канали.</p>
<p><strong>Time and Date Table (TDT).</strong> Метадані TDT передають поточну інформацію про час та дату у потоці MPEG-TS. Вони допомагають забезпечити синхронізацію між передавачем та приймачем.</p>
<p><strong>Descriptors.</strong> Дескриптори — це невеликі частини метаданих, які надають додаткову інформацію про вміст або компоненти у потоці MPEG-TS. Вони можуть містити деталі, такі як аудіо- та відеоформати кодування, інформацію про мову та інше.</p>
<p>Деякі великі стрімінг-платформи, що будуть приймати ваші стріми (наприклад, Youtube), обовʼязково скажуть вам, що якщо хочете мати сертифікацію, то в кожен ваш потік вкладіть правильні метадані (наприклад, з назвою компанії або енкодера), щоб ми потім легко могли визначити, хто це.</p>
<p>Тому дуже важливо перевірити, що туди вкладається.</p>
<h3>Статистика потоку в реальному часі</h3>
<p>Оскільки ми взяли потоковий протокол SRT як приклад, необхідно зазначити, що SRT надає потужний набір статистичних даних про сокет. Ці дані можна використовувати для спостереження за станом сокета і відстеження несправної поведінки. Статистика обчислюється незалежно на кожній стороні (одержувач і відправник) і не обмінюється між одноранговими партнерами, якщо тільки це не вказано явно. </p>
<p>Для тестування наші розробники створили плеєр, який може відображати цю статистику в режимі реального часу, і ви можете спостерігати значення багатьох параметрів. Незабаром ми плануємо зробити його відкритим. Але про тестування SRT поговоримо іншим разом.</p>
<img src="https://s.dou.ua/storage-files/image_63261655671694527418511.jpg" />
<h3>Test Environment</h3>
<p><strong>Internet connection.</strong> Перед тестуванням стрімінгу, переконайтеся що у вас стабільний інтернет із високою пропускною здатністю. Краще використовувати Ethernet зʼєднання з 1 Gbps. І тільки для тестування різних варіантів пропускної здатності використовуйте wifi (щоб змоделювати реального звичайного юзера) або інструменти, які допомагають гнучко налаштувати вашу пропускну здатність, latency, delay, lost packets і так далі. Для перевірки вашої мережі можна використати інструмент від Netflix <a href="https://fast.com/">fast.com</a>, або speedtest чи <a href="http://r1ch.net/projects/twitchtest">тулу твіча</a>.</p>
<p>Також оцініть вашу тестову машину, процесор та кількість оперативної памʼяті і постійно тримайте відкритим моніторинг системи. Вам потрібно зробити все для того щоб мінімізувати можливий вплив просідання ресурсів на відображення відео, яке ви тестуєте.</p>
<h3>Test Data</h3>
<p>Підготуйте багато тестових даних. Краще взяти якісно відзняте відео (нестиснуте) і самому закодувати його в потрібні кодеки, контейнери і т. д. Тут потрібно вибрати золоту середину всіх параметрів, які описано вище, в залежності від того, які з них частіше використовуються. Добре, коли є записані тестові відео, а також живі, як от стрім з вашої камери чи hardware енкодера. Вибирайте як складний тестовий контент, так і простий, це допоможе змоделювати різні тестові умови.</p>
<p>Ось деякі лінки на відкриті тестові відео.</p>
<p>streams:</p>
<ul>
<li><a href="https://ottverse.com/free-hls-m3u8-test-urls/">ottverse.com/free-hls-m3u8-test-urls</a></li>
<li><a href="https://github.com/bengarney/list-of-streams">github.com/...​bengarney/list-of-streams</a></li>
</ul>
<p>files:</p>
<ul>
<li><a href="https://mango.blender.org/download/">mango.blender.org/download</a></li>
<li><a href="http://download.tsi.telecom-paristech.fr/gpac/dataset/dash/uhd/">download.tsi.telecom-paristech.fr/gpac/dataset/dash/uhd</a></li>
<li><a href="https://medialab.sjtu.edu.cn/tag/dataset/">medialab.sjtu.edu.cn/tag/dataset</a></li>
<li><a href="https://ultravideo.fi/#testsequences">ultravideo.fi/#testsequences</a></li>
<li><a href="https://www.murideo.com/test-pattern-library.html">www.murideo.com/...​test-pattern-library.html</a></li>
</ul>
<h3>Види тестування</h3>
<p><strong>Юніт-тести.</strong> На першому етапі моліться Богу, щоб розробник написав кілька юніт-тестів і перевірив найдрібніші частини системи.</p>
<p><strong>Component testing.</strong> Це перший рівень тестування, де окремі компоненти вашої системи перевіряються на правильну роботу. Саме тут було б круто, щоб ви окремо перевірили, як працюють енкодер, декодер, мультиплексори, фільтри і т. д. Пірнати кудись глибше (якщо ви не лютий С++-розробник, не бачу сенсу), тому просто сподівайтесь, що у розробника в цих компонентах є юніт-тести.</p>
<p><strong>Integration testing:</strong></p>
<ul>
<li>Component Integration Testing. Тут можна почати проєктувати кейси, де ваші модулі могли б уже взаємодіяти одне з одним і моделювати кейси, де хтось і них не виконає свої задачі, як очікується.</li>
<li>System Integration Testing. На цьому рівні ви перевіряєте інтеграцію системи в цілому. Це включає перевірку взаємодії між різними компонентами, серверами, клієнтами та іншими частинами системи.</li>
<li>Hardware Software Integration Testing. Цей вид тестування орієнтований на перевірку взаємодії між апаратними та програмними компонентами системи.</li>
<li>Software Integration Testing. Тут ви зосереджуєтеся на інтеграції програмних компонентів, таких як програми, бібліотеки, сервіси та інші програмні модулі, що використовуються для стрімінгу.</li>
</ul>
<p><strong>System Testing.</strong> На цьому етапі ви вже маєте цілу систему, і ви перевіряєте, чи відповідає вона специфікаціям, чи працює коректно та задовольняє вимоги користувачів.</p>
<p>Після цього можна перейти до:</p>
<ul>
<li>Stability</li>
<li>Load</li>
<li>Stress</li>
<li>Recovery</li>
<li>Scalabillity</li>
<li>Volume</li>
<li>Reliability</li>
<li>Failover and Recovery</li>
</ul>
<p>Але про ці види поговоримо пізніше, бо я так ніколи не закінчу цю статтю.</p>
<h3>Інструменти</h3>
<p>Обов&rsquo;язково підготуйте інструменти, які будете використовувати для конвертації, передачі, приймання та аналізу потоків. Серед них є open source або trial, якого буде достатньо. Ось ті що використовую я:</p>
<ul>
<li>ffmpeg</li>
<li>ffprobe</li>
<li>mediainfo</li>
<li>ffplay</li>
<li>ffmetrics</li>
<li>ffbitrate</li>
<li>Elecard:
<ul>
<li>Stream Eye</li>
<li>Quality Estimator</li>
<li>Stream Analyzer</li>
<li>Quality Gates</li>
</ul>
</li>
<li>HandBrake</li>
<li>VidCOder</li>
<li>VQProbe</li>
<li>NetBalancer</li>
<li>NetLimiter</li>
<li>OBS</li>
<li>vMix</li>
<li>VLC</li>
<li>SRTSTressTools</li>
</ul>
<p>web:
— <a href="https://thumb.co.il/">thumb.co.il</a></p>
<p>— <a href="https://dvbsnoop.sourceforge.net/">dvbsnoop.sourceforge.net</a></p>
<p>— <a href="https://github.com/tsduck/tsduck">github.com/tsduck/tsduck</a></p>
<p>— <a href="https://www.digitalekabeltelevisie.nl/dvb_inspector/"><a href="https://www.digitalekabeltelevisie.nl/dvb_inspector">www.digitalekabeltelevisie.nl/dvb_inspector</a></a></p>
<p>— <a href="https://vmaf.dev/">VMAF.DEV</a></p>
<h3>Репортінг</h3>
<p>Всі баги, що ви знаходите, важливо максимально підкріпити степами, логами, тестовими даними, скріншотами та відео. Тоді розробники будуть щасливі, а вас не будуть спамити проханнями допомогти.</p>
<h2>Висновки</h2>
<ol>
<li>Щоб доставити до користувача продукт високої якості, потрібно визначитись, що саме ви робите і створювати грамотну стратегію тестування, яка зможе попередити більшість проблем.</li>
<li>Починати тестування ще до реалізації функціоналу (shift-left), бо потрібно багато ресурсів (особливо часу) на тестування.</li>
<li>Вивчити і розуміти, як працює ваша система, з яких компонентів складається і як вони взаємодіють.</li>
<li>Правильно розставити пріоритети в залежності від використання вашого продукту.</li>
<li>Бути уважним спостерігачем.</li>
</ol>
<p><em>Нагадуємо, що у нас є <a href="https://www.youtube.com/playlist?list=PLwj_3ikgO3CImNuyGZVC_lvBFXa2Khv0J">QA-подкаст</a>. Знаходьте більше цікавих матеріалів на <a href="https://www.youtube.com/@DOU_youtube/videos">DOU YouTube</a>.</em></p>

</article>
</div>


            
            
            
        </div>
    </main>
</body>

</html>